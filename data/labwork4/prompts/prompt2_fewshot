You are an AI agent for TypeScript dependency analysis. 
You perform the full pipeline: AST parsing → semantic analysis → dependency extraction → DSM → report generation.

Below are known example (X, y) pairs:

--- Example 1 ---
X: Small project with 2 modules: A.ts imports B.ts
y: No circular dependency detected. DSM shows one-direction coupling A → B. Architecture is stable.

--- Example 2 ---
X: Project with 3 modules: Core.ts exports utilities, UI.ts imports Core.ts, App.ts imports both UI and Core.
y: No cycles. DSM shows one-way dependency structure: Core → UI → App. Recommendation: keep Core as root module.

--- Example 3 ---
X: Project with mixed import types: 80% runtime imports, 20% type-only imports.
y: No cycles. Suggest grouping type-only utilities into a separate directory for modularity.

### Now analyze new project X:
Files:
-----------------------------
/A.ts
import { funcB } from "./B";
export const funcA = () => funcB();
-----------------------------
/B.ts
import { funcC } from "./C";
export const funcB = () => funcC();
-----------------------------
/C.ts
import { funcA } from "./A";
export const funcC = () => funcA();
-----------------------------

### Expected output format (y):
1) Dependency Graph (JSON)
2) DSM
3) Circular dependency findings
4) Structural architecture report
5) Improvement recommendations

Begin.

Output:
1) Dependency Graph
{
  "nodes": ["A", "B", "C"],
  "edges": [
    { "from": "A", "to": "B" },
    { "from": "B", "to": "C" },
    { "from": "C", "to": "A" }
  ]
}

2) DSM
      A   B   C
A     0   1   0
B     0   0   1
C     1   0   0

3) Circular Dependency Findings
A, B, and C form a 3-module circular dependency loop.
This structure creates high architectural risk due to mutual linkage and lack of module hierarchy.

4) Structural Report
- Graph density: 100%
- Coupling: Cyclic and strong
- Import types: 100% runtime imports
- Architecture Stability: Low

5) Improvement Recommendations
- Extract reusable logic from B.ts or C.ts into a new Core module
- Replace direct cyclic imports with event callbacks or dependency injection
- Establish a top-down dependency flow (Core → Services → Features)
